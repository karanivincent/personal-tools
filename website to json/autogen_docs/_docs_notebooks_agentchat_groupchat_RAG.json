{
    "url": "https://microsoft.github.io/autogen/docs/notebooks/agentchat_groupchat_RAG",
    "title": "Group Chat with Retrieval Augmented Generation",
    "sections": [
        {
            "title": "",
            "content": [
                {
                    "text": "\n\nAutoGen supports conversable agents powered by LLMs, tools, or humans,\nperforming tasks collectively via automated chat. This framework allows\ntool use and human participation through multi-agent conversation.\nPlease find documentation about this feature\nhere\n.\n\nSome extra dependencies are needed for this notebook, which can be installed via pip:"
                },
                {
                    "code": {
                        "language": "bash",
                        "script": "pip install pyautogen[retrievechat]"
                    }
                },
                {
                    "text": "For more information, please refer to the\ninstallation guide\n."
                }
            ],
            "subsections": []
        },
        {
            "title": "Set your API Endpoint\n​",
            "content": [
                {
                    "text": "The\nconfig_list_from_json\nfunction loads a list of configurations from an environment variable or\na json file."
                },
                {
                    "code": {
                        "language": "python",
                        "script": "import\nchromadb\nfrom\ntyping_extensions\nimport\nAnnotated\nimport\nautogen\nfrom\nautogen\nimport\nAssistantAgent\nfrom\nautogen\n.\nagentchat\n.\ncontrib\n.\nretrieve_user_proxy_agent\nimport\nRetrieveUserProxyAgent\nconfig_list\n=\nautogen\n.\nconfig_list_from_json\n(\n\"OAI_CONFIG_LIST\"\n)\nprint\n(\n\"LLM models: \"\n,\n[\nconfig_list\n[\ni\n]\n[\n\"model\"\n]\nfor\ni\nin\nrange\n(\nlen\n(\nconfig_list\n)\n)\n]\n)"
                    }
                },
                {
                    "code": {
                        "language": "text",
                        "script": "LLM models:  ['gpt4-1106-preview', 'gpt-35-turbo', 'gpt-35-turbo-0613']"
                    }
                },
                {
                    "text": "Learn more about configuring LLMs for agents\nhere\n."
                }
            ],
            "subsections": []
        },
        {
            "title": "Construct Agents\n​",
            "content": [
                {
                    "code": {
                        "language": "python",
                        "script": "def\ntermination_msg\n(\nx\n)\n:\nreturn\nisinstance\n(\nx\n,\ndict\n)\nand\n\"TERMINATE\"\n==\nstr\n(\nx\n.\nget\n(\n\"content\"\n,\n\"\"\n)\n)\n[\n-\n9\n:\n]\n.\nupper\n(\n)\nllm_config\n=\n{\n\"config_list\"\n:\nconfig_list\n,\n\"timeout\"\n:\n60\n,\n\"temperature\"\n:\n0.8\n,\n\"seed\"\n:\n1234\n}\nboss\n=\nautogen\n.\nUserProxyAgent\n(\nname\n=\n\"Boss\"\n,\nis_termination_msg\n=\ntermination_msg\n,\nhuman_input_mode\n=\n\"NEVER\"\n,\ncode_execution_config\n=\nFalse\n,\n# we don't want to execute code in this case.\ndefault_auto_reply\n=\n\"Reply `TERMINATE` if the task is done.\"\n,\ndescription\n=\n\"The boss who ask questions and give tasks.\"\n,\n)\nboss_aid\n=\nRetrieveUserProxyAgent\n(\nname\n=\n\"Boss_Assistant\"\n,\nis_termination_msg\n=\ntermination_msg\n,\nhuman_input_mode\n=\n\"NEVER\"\n,\ndefault_auto_reply\n=\n\"Reply `TERMINATE` if the task is done.\"\n,\nmax_consecutive_auto_reply\n=\n3\n,\nretrieve_config\n=\n{\n\"task\"\n:\n\"code\"\n,\n\"docs_path\"\n:\n\"https://raw.githubusercontent.com/microsoft/FLAML/main/website/docs/Examples/Integrate%20-%20Spark.md\"\n,\n\"chunk_token_size\"\n:\n1000\n,\n\"model\"\n:\nconfig_list\n[\n0\n]\n[\n\"model\"\n]\n,\n\"collection_name\"\n:\n\"groupchat\"\n,\n\"get_or_create\"\n:\nTrue\n,\n}\n,\ncode_execution_config\n=\nFalse\n,\n# we don't want to execute code in this case.\ndescription\n=\n\"Assistant who has extra content retrieval power for solving difficult problems.\"\n,\n)\ncoder\n=\nAssistantAgent\n(\nname\n=\n\"Senior_Python_Engineer\"\n,\nis_termination_msg\n=\ntermination_msg\n,\nsystem_message\n=\n\"You are a senior python engineer, you provide python code to answer questions. Reply `TERMINATE` in the end when everything is done.\"\n,\nllm_config\n=\nllm_config\n,\ndescription\n=\n\"Senior Python Engineer who can write code to solve problems and answer questions.\"\n,\n)\npm\n=\nautogen\n.\nAssistantAgent\n(\nname\n=\n\"Product_Manager\"\n,\nis_termination_msg\n=\ntermination_msg\n,\nsystem_message\n=\n\"You are a product manager. Reply `TERMINATE` in the end when everything is done.\"\n,\nllm_config\n=\nllm_config\n,\ndescription\n=\n\"Product Manager who can design and plan the project.\"\n,\n)\nreviewer\n=\nautogen\n.\nAssistantAgent\n(\nname\n=\n\"Code_Reviewer\"\n,\nis_termination_msg\n=\ntermination_msg\n,\nsystem_message\n=\n\"You are a code reviewer. Reply `TERMINATE` in the end when everything is done.\"\n,\nllm_config\n=\nllm_config\n,\ndescription\n=\n\"Code Reviewer who can review the code.\"\n,\n)\nPROBLEM\n=\n\"How to use spark for parallel training in FLAML? Give me sample code.\"\ndef\n_reset_agents\n(\n)\n:\nboss\n.\nreset\n(\n)\nboss_aid\n.\nreset\n(\n)\ncoder\n.\nreset\n(\n)\npm\n.\nreset\n(\n)\nreviewer\n.\nreset\n(\n)\ndef\nrag_chat\n(\n)\n:\n_reset_agents\n(\n)\ngroupchat\n=\nautogen\n.\nGroupChat\n(\nagents\n=\n[\nboss_aid\n,\npm\n,\ncoder\n,\nreviewer\n]\n,\nmessages\n=\n[\n]\n,\nmax_round\n=\n12\n,\nspeaker_selection_method\n=\n\"round_robin\"\n)\nmanager\n=\nautogen\n.\nGroupChatManager\n(\ngroupchat\n=\ngroupchat\n,\nllm_config\n=\nllm_config\n)\n# Start chatting with boss_aid as this is the user proxy agent.\nboss_aid\n.\ninitiate_chat\n(\nmanager\n,\nmessage\n=\nboss_aid\n.\nmessage_generator\n,\nproblem\n=\nPROBLEM\n,\nn_results\n=\n3\n,\n)\ndef\nnorag_chat\n(\n)\n:\n_reset_agents\n(\n)\ngroupchat\n=\nautogen\n.\nGroupChat\n(\nagents\n=\n[\nboss\n,\npm\n,\ncoder\n,\nreviewer\n]\n,\nmessages\n=\n[\n]\n,\nmax_round\n=\n12\n,\nspeaker_selection_method\n=\n\"auto\"\n,\nallow_repeat_speaker\n=\nFalse\n,\n)\nmanager\n=\nautogen\n.\nGroupChatManager\n(\ngroupchat\n=\ngroupchat\n,\nllm_config\n=\nllm_config\n)\n# Start chatting with the boss as this is the user proxy agent.\nboss\n.\ninitiate_chat\n(\nmanager\n,\nmessage\n=\nPROBLEM\n,\n)\ndef\ncall_rag_chat\n(\n)\n:\n_reset_agents\n(\n)\n# In this case, we will have multiple user proxy agents and we don't initiate the chat\n# with RAG user proxy agent.\n# In order to use RAG user proxy agent, we need to wrap RAG agents in a function and call\n# it from other agents.\ndef\nretrieve_content\n(\nmessage\n:\nAnnotated\n[\nstr\n,\n\"Refined message which keeps the original meaning and can be used to retrieve content for code generation and question answering.\"\n,\n]\n,\nn_results\n:\nAnnotated\n[\nint\n,\n\"number of results\"\n]\n=\n3\n,\n)\n-\n>\nstr\n:\nboss_aid\n.\nn_results\n=\nn_results\n# Set the number of results to be retrieved.\n# Check if we need to update the context.\nupdate_context_case1\n,\nupdate_context_case2\n=\nboss_aid\n.\n_check_update_context\n(\nmessage\n)\nif\n(\nupdate_context_case1\nor\nupdate_context_case2\n)\nand\nboss_aid\n.\nupdate_context\n:\nboss_aid\n.\nproblem\n=\nmessage\nif\nnot\nhasattr\n(\nboss_aid\n,\n\"problem\"\n)\nelse\nboss_aid\n.\nproblem\n_\n,\nret_msg\n=\nboss_aid\n.\n_generate_retrieve_user_reply\n(\nmessage\n)\nelse\n:\n_context\n=\n{\n\"problem\"\n:\nmessage\n,\n\"n_results\"\n:\nn_results\n}\nret_msg\n=\nboss_aid\n.\nmessage_generator\n(\nboss_aid\n,\nNone\n,\n_context\n)\nreturn\nret_msg\nif\nret_msg\nelse\nmessage\nboss_aid\n.\nhuman_input_mode\n=\n\"NEVER\"\n# Disable human input for boss_aid since it only retrieves content.\nfor\ncaller\nin\n[\npm\n,\ncoder\n,\nreviewer\n]\n:\nd_retrieve_content\n=\ncaller\n.\nregister_for_llm\n(\ndescription\n=\n\"retrieve content for code generation and question answering.\"\n,\napi_style\n=\n\"function\"\n)\n(\nretrieve_content\n)\nfor\nexecutor\nin\n[\nboss\n,\npm\n]\n:\nexecutor\n.\nregister_for_execution\n(\n)\n(\nd_retrieve_content\n)\ngroupchat\n=\nautogen\n.\nGroupChat\n(\nagents\n=\n[\nboss\n,\npm\n,\ncoder\n,\nreviewer\n]\n,\nmessages\n=\n[\n]\n,\nmax_round\n=\n12\n,\nspeaker_selection_method\n=\n\"round_robin\"\n,\nallow_repeat_speaker\n=\nFalse\n,\n)\nmanager\n=\nautogen\n.\nGroupChatManager\n(\ngroupchat\n=\ngroupchat\n,\nllm_config\n=\nllm_config\n)\n# Start chatting with the boss as this is the user proxy agent.\nboss\n.\ninitiate_chat\n(\nmanager\n,\nmessage\n=\nPROBLEM\n,\n)"
                    }
                },
                {
                    "code": {
                        "language": "text",
                        "script": "/home/lijiang1/anaconda3/envs/autogen/lib/python3.10/site-packages/transformers/utils/generic.py:311: UserWarning: torch.utils._pytree._register_pytree_node is deprecated. Please use torch.utils._pytree.register_pytree_node instead.\ntorch.utils._pytree._register_pytree_node("
                    }
                }
            ],
            "subsections": []
        },
        {
            "title": "Start Chat\n​",
            "content": [],
            "subsections": [
                {
                    "title": "UserProxyAgent doesn’t get the correct code\n​",
                    "content": [
                        {
                            "text": "FLAML\nwas open sourced in 2020, so\nChatGPT is familiar with it. However, Spark-related APIs were added in\n2022, so they were not in ChatGPT’s training data. As a result, we end\nup with invalid code."
                        },
                        {
                            "code": {
                                "language": "python",
                                "script": "norag_chat\n(\n)"
                            }
                        },
                        {
                            "code": {
                                "language": "text",
                                "script": "Boss\n(\nto\nchat_manager\n)\n:\nHow to use spark for parallel training in FLAML? Give me sample code.\n--------------------------------------------------------------------------------\nSenior_Python_Engineer\n(\nto\nchat_manager\n)\n:\nTo use Spark for parallel training in FLAML (Fast and Lightweight AutoML), you would need to set up a Spark cluster and utilize the `spark` backend for joblib, which FLAML uses internally for parallel training. Here’s an example of how you might set up and use Spark with FLAML for AutoML tasks:\nFirstly, ensure that you have the Spark cluster set up and the `pyspark` and `joblib-spark` packages installed in your environment. You can install the required packages using pip if they are not already installed:\n```python\n!pip install flaml pyspark joblib-spark\n```\nHere's a sample code snippet that demonstrates how to use FLAML with Spark for parallel training:\n```python\nfrom flaml import AutoML\nfrom pyspark.sql import SparkSession\nfrom sklearn.datasets import load_digits\nfrom joblibspark import register_spark\n# Initialize a Spark session\nspark = SparkSession.builder \\\n.master(\"local[*]\") \\\n.appName(\"FLAML_Spark_Example\") \\\n.getOrCreate()\n# Register the joblib spark backend\nregister_spark()  # This registers the backend for parallel processing\n# Load sample data\nX, y = load_digits(return_X_y=True)\n# Initialize an AutoML instance\nautoml = AutoML()\n# Define the settings for the AutoML run\nsettings = {\n\"time_budget\": 60,  # Total running time in seconds\n\"metric\": 'accuracy',  # Primary metric for evaluation\n\"task\": 'classification',  # Task type\n\"n_jobs\": -1,  # Number of jobs to run in parallel (use -1 for all)\n\"estimator_list\": ['lgbm', 'rf', 'xgboost'],  # List of estimators to consider\n\"log_file_name\": \"flaml_log.txt\",  # Log file name\n}\n# Run the AutoML search with Spark backend\nautoml.fit(X_train=X, y_train=y, **settings)\n# Output the best model and its performance\nprint(f\"Best ML model: {automl.model}\")\nprint(f\"Best ML model's accuracy: {automl.best_loss}\")\n# Stop the Spark session\nspark.stop()\n```\nThe `register_spark()` function from `joblib-spark` is used to register the Spark backend with joblib, which is utilized for parallel training within FLAML. The `n_jobs=-1` parameter tells FLAML to use all available Spark executors for parallel training.\nPlease note that the actual process of setting up a Spark cluster can be complex and might involve additional steps such as configuring Spark workers, allocating resources, and more, which are beyond the scope of this code snippet.\nIf you encounter any issues or need to adjust configurations for your specific Spark setup, please refer to the Spark and FLAML documentation for more details.\nWhen you run the code, ensure that your Spark cluster is properly configured and accessible from your Python environment. Adjust the `.master(\"local[*]\")` to point to your Spark master's URL if you are running a cluster that is not local.\n--------------------------------------------------------------------------------\nTo use Spark for parallel training in FLAML (Fast and Lightweight AutoML), you would need to set up a Spark cluster and utilize the `spark` backend for joblib, which FLAML uses internally for parallel training. Here’s an example of how you might set up and use Spark with FLAML for AutoML tasks:\nFirstly, ensure that you have the Spark cluster set up and the `pyspark` and `joblib-spark` packages installed in your environment. You can install the required packages using pip if they are not already installed:\n```python\n!pip install flaml pyspark joblib-spark\n```\nHere's a sample code snippet that demonstrates how to use FLAML with Spark for parallel training:\n```python\nfrom flaml import AutoML\nfrom pyspark.sql import SparkSession\nfrom sklearn.datasets import load_digits\nfrom joblibspark import register_spark\n# Initialize a Spark session\nspark = SparkSession.builder \\\n.master(\"local[*]\") \\\n.appName(\"FLAML_Spark_Example\") \\\n.getOrCreate()\n# Register the joblib spark backend\nregister_spark()  # This registers the backend for parallel processing\n# Load sample data\nX, y = load_digits(return_X_y=True)\n# Initialize an AutoML instance\nautoml = AutoML()\n# Define the settings for the AutoML run\nsettings = {\n\"time_budget\": 60,  # Total running time in seconds\n\"metric\": 'accuracy',  # Primary metric for evaluation\n\"task\": 'classification',  # Task type\n\"n_jobs\": -1,  # Number of jobs to run in parallel (use -1 for all)\n\"estimator_list\": ['lgbm', 'rf', 'xgboost'],  # List of estimators to consider\n\"log_file_name\": \"flaml_log.txt\",  # Log file name\n}\n# Run the AutoML search with Spark backend\nautoml.fit(X_train=X, y_train=y, **settings)\n# Output the best model and its performance\nprint(f\"Best ML model: {automl.model}\")\nprint(f\"Best ML model's accuracy: {automl.best_loss}\")\n# Stop the Spark session\nspark.stop()\n```\nThe `register_spark()` function from `joblib-spark` is used to register the Spark backend with joblib, which is utilized for parallel training within FLAML. The `n_jobs=-1` parameter tells FLAML to use all available Spark executors for parallel training.\nPlease note that the actual process of setting up a Spark cluster can be complex and might involve additional steps such as configuring Spark workers, allocating resources, and more, which are beyond the scope of this code snippet.\nIf you encounter any issues or need to adjust configurations for your specific Spark setup, please refer to the Spark and FLAML documentation for more details.\nWhen you run the code, ensure that your Spark cluster is properly configured and accessible from your Python environment. Adjust the `.master(\"local[*]\")` to point to your Spark master's URL if you are running a cluster that is not local.\n--------------------------------------------------------------------------------\nCode_Reviewer\n(\nto\nchat_manager\n)\n:\nTERMINATE\n--------------------------------------------------------------------------------"
                            }
                        }
                    ],
                    "subsections": []
                },
                {
                    "title": "RetrieveUserProxyAgent get the correct code\n​",
                    "content": [
                        {
                            "text": "Since RetrieveUserProxyAgent can perform retrieval-augmented generation\nbased on the given documentation file, ChatGPT can generate the correct\ncode for us!"
                        },
                        {
                            "code": {
                                "language": "python",
                                "script": "rag_chat\n(\n)\n# type exit to terminate the chat"
                            }
                        },
                        {
                            "code": {
                                "language": "text",
                                "script": "2024-04-07 18:26:04,562 - autogen.agentchat.contrib.retrieve_user_proxy_agent - INFO - Use the existing collection `groupchat`.\n2024-04-07 18:26:05,485 - autogen.agentchat.contrib.retrieve_user_proxy_agent - INFO - Found 1 chunks.\nNumber of requested results 3 is greater than number of elements in index 1, updating n_results = 1\nModel gpt4-1106-preview not found. Using cl100k_base encoding."
                            }
                        },
                        {
                            "code": {
                                "language": "text",
                                "script": "Trying to create collection.\nVectorDB returns doc_ids:  [['bdfbc921']]\nAdding content of doc bdfbc921 to context.\nBoss_Assistant\n(\nto\nchat_manager\n)\n:\nYou're a retrieve augmented coding assistant. You answer user's questions based on your own knowledge and the\ncontext provided by the user.\nIf you can't answer the question with or without the current context, you should reply exactly `UPDATE CONTEXT`.\nFor code generation, you must obey the following rules:\nRule 1. You MUST NOT install any packages because all the packages needed are already installed.\nRule 2. You must follow the formats below to write your code:\n```language\n# your code\n```\nUser's question is: How to use spark for parallel training in FLAML? Give me sample code.\nContext is: # Integrate - Spark\nFLAML has integrated Spark for distributed training. There are two main aspects of integration with Spark:\n- Use Spark ML estimators for AutoML.\n- Use Spark to run training in parallel spark jobs.\n## Spark ML Estimators\nFLAML integrates estimators based on Spark ML models. These models are trained in parallel using Spark, so we called them Spark estimators. To use these models, you first need to organize your data in the required format.\n### Data\nFor Spark estimators, AutoML only consumes Spark data. FLAML provides a convenient function `to_pandas_on_spark` in the `flaml.automl.spark.utils` module to convert your data into a pandas-on-spark (`pyspark.pandas`) dataframe/series, which Spark estimators require.\nThis utility function takes data in the form of a `pandas.Dataframe` or `pyspark.sql.Dataframe` and converts it into a pandas-on-spark dataframe. It also takes `pandas.Series` or `pyspark.sql.Dataframe` and converts it into a [pandas-on-spark](https://spark.apache.org/docs/latest/api/python/user_guide/pandas_on_spark/index.html) series. If you pass in a `pyspark.pandas.Dataframe`, it will not make any changes.\nThis function also accepts optional arguments `index_col` and `default_index_type`.\n- `index_col` is the column name to use as the index, default is None.\n- `default_index_type` is the default index type, default is \"distributed-sequence\". More info about default index type could be found on Spark official [documentation](https://spark.apache.org/docs/latest/api/python/user_guide/pandas_on_spark/options.html#default-index-type)\nHere is an example code snippet for Spark Data:\n```python\nimport pandas as pd\nfrom flaml.automl.spark.utils import to_pandas_on_spark\n# Creating a dictionary\ndata = {\n\"Square_Feet\": [800, 1200, 1800, 1500, 850],\n\"Age_Years\": [20, 15, 10, 7, 25],\n\"Price\": [100000, 200000, 300000, 240000, 120000],\n}\n# Creating a pandas DataFrame\ndataframe = pd.DataFrame(data)\nlabel = \"Price\"\n# Convert to pandas-on-spark dataframe\npsdf = to_pandas_on_spark(dataframe)\n```\nTo use Spark ML models you need to format your data appropriately. Specifically, use [`VectorAssembler`](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.ml.feature.VectorAssembler.html) to merge all feature columns into a single vector column.\nHere is an example of how to use it:\n```python\nfrom pyspark.ml.feature import VectorAssembler\ncolumns = psdf.columns\nfeature_cols = [col for col in columns if col != label]\nfeaturizer = VectorAssembler(inputCols=feature_cols, outputCol=\"features\")\npsdf = featurizer.transform(psdf.to_spark(index_col=\"index\"))[\"index\", \"features\"]\n```\nLater in conducting the experiment, use your pandas-on-spark data like non-spark data and pass them using `X_train, y_train` or `dataframe, label`.\n### Estimators\n#### Model List\n- `lgbm_spark`: The class for fine-tuning Spark version LightGBM models, using [SynapseML](https://microsoft.github.io/SynapseML/docs/features/lightgbm/about/) API.\n#### Usage\nFirst, prepare your data in the required format as described in the previous section.\nBy including the models you intend to try in the `estimators_list` argument to `flaml.automl`, FLAML will start trying configurations for these models. If your input is Spark data, FLAML will also use estimators with the `_spark` postfix by default, even if you haven't specified them.\nHere is an example code snippet using SparkML models in AutoML:\n```python\nimport flaml\n# prepare your data in pandas-on-spark format as we previously mentioned\nautoml = flaml.AutoML()\nsettings = {\n\"time_budget\": 30,\n\"metric\": \"r2\",\n\"estimator_list\": [\"lgbm_spark\"],  # this setting is optional\n\"task\": \"regression\",\n}\nautoml.fit(\ndataframe=psdf,\nlabel=label,\n**settings,\n)\n```\n[Link to notebook](https://github.com/microsoft/FLAML/blob/main/notebook/automl_bankrupt_synapseml.ipynb) | [Open in colab](https://colab.research.google.com/github/microsoft/FLAML/blob/main/notebook/automl_bankrupt_synapseml.ipynb)\n## Parallel Spark Jobs\nYou can activate Spark as the parallel backend during parallel tuning in both [AutoML](/docs/Use-Cases/Task-Oriented-AutoML#parallel-tuning) and [Hyperparameter Tuning](/docs/Use-Cases/Tune-User-Defined-Function#parallel-tuning), by setting the `use_spark` to `true`. FLAML will dispatch your job to the distributed Spark backend using [`joblib-spark`](https://github.com/joblib/joblib-spark).\nPlease note that you should not set `use_spark` to `true` when applying AutoML and Tuning for Spark Data. This is because only SparkML models will be used for Spark Data in AutoML and Tuning. As SparkML models run in parallel, there is no need to distribute them with `use_spark` again.\nAll the Spark-related arguments are stated below. These arguments are available in both Hyperparameter Tuning and AutoML:\n- `use_spark`: boolean, default=False | Whether to use spark to run the training in parallel spark jobs. This can be used to accelerate training on large models and large datasets, but will incur more overhead in time and thus slow down training in some cases. GPU training is not supported yet when use_spark is True. For Spark clusters, by default, we will launch one trial per executor. However, sometimes we want to launch more trials than the number of executors (e.g., local mode). In this case, we can set the environment variable `FLAML_MAX_CONCURRENT` to override the detected `num_executors`. The final number of concurrent trials will be the minimum of `n_concurrent_trials` and `num_executors`.\n- `n_concurrent_trials`: int, default=1 | The number of concurrent trials. When n_concurrent_trials > 1, FLAML performes parallel tuning.\n- `force_cancel`: boolean, default=False | Whether to forcely cancel Spark jobs if the search time exceeded the time budget. Spark jobs include parallel tuning jobs and Spark-based model training jobs.\nAn example code snippet for using parallel Spark jobs:\n```python\nimport flaml\nautoml_experiment = flaml.AutoML()\nautoml_settings = {\n\"time_budget\": 30,\n\"metric\": \"r2\",\n\"task\": \"regression\",\n\"n_concurrent_trials\": 2,\n\"use_spark\": True,\n\"force_cancel\": True,  # Activating the force_cancel option can immediately halt Spark jobs once they exceed the allocated time_budget.\n}\nautoml.fit(\ndataframe=dataframe,\nlabel=label,\n**automl_settings,\n)\n```\n[Link to notebook](https://github.com/microsoft/FLAML/blob/main/notebook/integrate_spark.ipynb) | [Open in colab](https://colab.research.google.com/github/microsoft/FLAML/blob/main/notebook/integrate_spark.ipynb)\n--------------------------------------------------------------------------------\nBoss_Assistant\n(\nto\nchat_manager\n)\n:\nYou're a retrieve augmented coding assistant. You answer user's questions based on your own knowledge and the\ncontext provided by the user.\nIf you can't answer the question with or without the current context, you should reply exactly `UPDATE CONTEXT`.\nFor code generation, you must obey the following rules:\nRule 1. You MUST NOT install any packages because all the packages needed are already installed.\nRule 2. You must follow the formats below to write your code:\n```language\n# your code\n```\nUser's question is: How to use spark for parallel training in FLAML? Give me sample code.\nContext is: # Integrate - Spark\nFLAML has integrated Spark for distributed training. There are two main aspects of integration with Spark:\n- Use Spark ML estimators for AutoML.\n- Use Spark to run training in parallel spark jobs.\n## Spark ML Estimators\nFLAML integrates estimators based on Spark ML models. These models are trained in parallel using Spark, so we called them Spark estimators. To use these models, you first need to organize your data in the required format.\n### Data\nFor Spark estimators, AutoML only consumes Spark data. FLAML provides a convenient function `to_pandas_on_spark` in the `flaml.automl.spark.utils` module to convert your data into a pandas-on-spark (`pyspark.pandas`) dataframe/series, which Spark estimators require.\nThis utility function takes data in the form of a `pandas.Dataframe` or `pyspark.sql.Dataframe` and converts it into a pandas-on-spark dataframe. It also takes `pandas.Series` or `pyspark.sql.Dataframe` and converts it into a [pandas-on-spark](https://spark.apache.org/docs/latest/api/python/user_guide/pandas_on_spark/index.html) series. If you pass in a `pyspark.pandas.Dataframe`, it will not make any changes.\nThis function also accepts optional arguments `index_col` and `default_index_type`.\n- `index_col` is the column name to use as the index, default is None.\n- `default_index_type` is the default index type, default is \"distributed-sequence\". More info about default index type could be found on Spark official [documentation](https://spark.apache.org/docs/latest/api/python/user_guide/pandas_on_spark/options.html#default-index-type)\nHere is an example code snippet for Spark Data:\n```python\nimport pandas as pd\nfrom flaml.automl.spark.utils import to_pandas_on_spark\n# Creating a dictionary\ndata = {\n\"Square_Feet\": [800, 1200, 1800, 1500, 850],\n\"Age_Years\": [20, 15, 10, 7, 25],\n\"Price\": [100000, 200000, 300000, 240000, 120000],\n}\n# Creating a pandas DataFrame\ndataframe = pd.DataFrame(data)\nlabel = \"Price\"\n# Convert to pandas-on-spark dataframe\npsdf = to_pandas_on_spark(dataframe)\n```\nTo use Spark ML models you need to format your data appropriately. Specifically, use [`VectorAssembler`](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.ml.feature.VectorAssembler.html) to merge all feature columns into a single vector column.\nHere is an example of how to use it:\n```python\nfrom pyspark.ml.feature import VectorAssembler\ncolumns = psdf.columns\nfeature_cols = [col for col in columns if col != label]\nfeaturizer = VectorAssembler(inputCols=feature_cols, outputCol=\"features\")\npsdf = featurizer.transform(psdf.to_spark(index_col=\"index\"))[\"index\", \"features\"]\n```\nLater in conducting the experiment, use your pandas-on-spark data like non-spark data and pass them using `X_train, y_train` or `dataframe, label`.\n### Estimators\n#### Model List\n- `lgbm_spark`: The class for fine-tuning Spark version LightGBM models, using [SynapseML](https://microsoft.github.io/SynapseML/docs/features/lightgbm/about/) API.\n#### Usage\nFirst, prepare your data in the required format as described in the previous section.\nBy including the models you intend to try in the `estimators_list` argument to `flaml.automl`, FLAML will start trying configurations for these models. If your input is Spark data, FLAML will also use estimators with the `_spark` postfix by default, even if you haven't specified them.\nHere is an example code snippet using SparkML models in AutoML:\n```python\nimport flaml\n# prepare your data in pandas-on-spark format as we previously mentioned\nautoml = flaml.AutoML()\nsettings = {\n\"time_budget\": 30,\n\"metric\": \"r2\",\n\"estimator_list\": [\"lgbm_spark\"],  # this setting is optional\n\"task\": \"regression\",\n}\nautoml.fit(\ndataframe=psdf,\nlabel=label,\n**settings,\n)\n```\n[Link to notebook](https://github.com/microsoft/FLAML/blob/main/notebook/automl_bankrupt_synapseml.ipynb) | [Open in colab](https://colab.research.google.com/github/microsoft/FLAML/blob/main/notebook/automl_bankrupt_synapseml.ipynb)\n## Parallel Spark Jobs\nYou can activate Spark as the parallel backend during parallel tuning in both [AutoML](/docs/Use-Cases/Task-Oriented-AutoML#parallel-tuning) and [Hyperparameter Tuning](/docs/Use-Cases/Tune-User-Defined-Function#parallel-tuning), by setting the `use_spark` to `true`. FLAML will dispatch your job to the distributed Spark backend using [`joblib-spark`](https://github.com/joblib/joblib-spark).\nPlease note that you should not set `use_spark` to `true` when applying AutoML and Tuning for Spark Data. This is because only SparkML models will be used for Spark Data in AutoML and Tuning. As SparkML models run in parallel, there is no need to distribute them with `use_spark` again.\nAll the Spark-related arguments are stated below. These arguments are available in both Hyperparameter Tuning and AutoML:\n- `use_spark`: boolean, default=False | Whether to use spark to run the training in parallel spark jobs. This can be used to accelerate training on large models and large datasets, but will incur more overhead in time and thus slow down training in some cases. GPU training is not supported yet when use_spark is True. For Spark clusters, by default, we will launch one trial per executor. However, sometimes we want to launch more trials than the number of executors (e.g., local mode). In this case, we can set the environment variable `FLAML_MAX_CONCURRENT` to override the detected `num_executors`. The final number of concurrent trials will be the minimum of `n_concurrent_trials` and `num_executors`.\n- `n_concurrent_trials`: int, default=1 | The number of concurrent trials. When n_concurrent_trials > 1, FLAML performes parallel tuning.\n- `force_cancel`: boolean, default=False | Whether to forcely cancel Spark jobs if the search time exceeded the time budget. Spark jobs include parallel tuning jobs and Spark-based model training jobs.\nAn example code snippet for using parallel Spark jobs:\n```python\nimport flaml\nautoml_experiment = flaml.AutoML()\nautoml_settings = {\n\"time_budget\": 30,\n\"metric\": \"r2\",\n\"task\": \"regression\",\n\"n_concurrent_trials\": 2,\n\"use_spark\": True,\n\"force_cancel\": True,  # Activating the force_cancel option can immediately halt Spark jobs once they exceed the allocated time_budget.\n}\nautoml.fit(\ndataframe=dataframe,\nlabel=label,\n**automl_settings,\n)\n```\n[Link to notebook](https://github.com/microsoft/FLAML/blob/main/notebook/integrate_spark.ipynb) | [Open in colab](https://colab.research.google.com/github/microsoft/FLAML/blob/main/notebook/integrate_spark.ipynb)\n--------------------------------------------------------------------------------\nProduct_Manager\n(\nto\nchat_manager\n)\n:\n```python\nfrom flaml.automl import AutoML\nfrom flaml.automl.spark.utils import to_pandas_on_spark\nfrom pyspark.ml.feature import VectorAssembler\nimport pandas as pd\n# Sample data in a dictionary\ndata = {\n\"Square_Feet\": [800, 1200, 1800, 1500, 850],\n\"Age_Years\": [20, 15, 10, 7, 25],\n\"Price\": [100000, 200000, 300000, 240000, 120000],\n}\n# Convert dictionary to pandas DataFrame\ndataframe = pd.DataFrame(data)\nlabel = \"Price\"\n# Convert pandas DataFrame to pandas-on-spark DataFrame\npsdf = to_pandas_on_spark(dataframe)\n# Use VectorAssembler to merge feature columns into a single vector column\nfeature_cols = [col for col in psdf.columns if col != label]\nfeaturizer = VectorAssembler(inputCols=feature_cols, outputCol=\"features\")\npsdf = featurizer.transform(psdf.to_spark(index_col=\"index\"))[\"index\", \"features\", label]\n# Initialize AutoML instance\nautoml = AutoML()\n# AutoML settings\nautoml_settings = {\n\"time_budget\": 30,  # Total running time in seconds\n\"metric\": \"r2\",     # Evaluation metric\n\"task\": \"regression\",\n\"n_concurrent_trials\": 2,   # Number of concurrent Spark jobs\n\"use_spark\": True,          # Enable Spark for parallel training\n\"force_cancel\": True,       # Force cancel Spark jobs if they exceed the time budget\n\"estimator_list\": [\"lgbm_spark\"]  # Optional: Specific estimator to use\n}\n# Run AutoML fit with pandas-on-spark dataframe\nautoml.fit(\ndataframe=psdf,\nlabel=label,\n**automl_settings,\n)\n```\nTERMINATE\n--------------------------------------------------------------------------------"
                            }
                        }
                    ],
                    "subsections": []
                },
                {
                    "title": "Call RetrieveUserProxyAgent while init chat with another user proxy agent\n​",
                    "content": [
                        {
                            "text": "Sometimes, there might be a need to use RetrieveUserProxyAgent in group\nchat without initializing the chat with it. In such scenarios, it\nbecomes essential to create a function that wraps the RAG agents and\nallows them to be called from other agents."
                        },
                        {
                            "code": {
                                "language": "python",
                                "script": "call_rag_chat\n(\n)"
                            }
                        },
                        {
                            "code": {
                                "language": "text",
                                "script": "Boss\n(\nto\nchat_manager\n)\n:\nHow to use spark for parallel training in FLAML? Give me sample code.\n--------------------------------------------------------------------------------\nProduct_Manager\n(\nto\nchat_manager\n)\n:\n***** Suggested function call: retrieve_content *****\nArguments:\n{\"message\":\"using Apache Spark for parallel training in FLAML with sample code\"}\n*****************************************************\n--------------------------------------------------------------------------------\n>>>>>>>> EXECUTING FUNCTION retrieve_content...\nVectorDB returns doc_ids:  [['bdfbc921']]\nAdding content of doc bdfbc921 to context.\nBoss\n(\nto\nchat_manager\n)\n:\n***** Response from calling function (retrieve_content) *****\nYou're a retrieve augmented coding assistant. You answer user's questions based on your own knowledge and the\ncontext provided by the user.\nIf you can't answer the question with or without the current context, you should reply exactly `UPDATE CONTEXT`.\nFor code generation, you must obey the following rules:\nRule 1. You MUST NOT install any packages because all the packages needed are already installed.\nRule 2. You must follow the formats below to write your code:\n```language\n# your code\n```\nUser's question is: using Apache Spark for parallel training in FLAML with sample code\nContext is: # Integrate - Spark\nFLAML has integrated Spark for distributed training. There are two main aspects of integration with Spark:\n- Use Spark ML estimators for AutoML.\n- Use Spark to run training in parallel spark jobs.\n## Spark ML Estimators\nFLAML integrates estimators based on Spark ML models. These models are trained in parallel using Spark, so we called them Spark estimators. To use these models, you first need to organize your data in the required format.\n### Data\nFor Spark estimators, AutoML only consumes Spark data. FLAML provides a convenient function `to_pandas_on_spark` in the `flaml.automl.spark.utils` module to convert your data into a pandas-on-spark (`pyspark.pandas`) dataframe/series, which Spark estimators require.\nThis utility function takes data in the form of a `pandas.Dataframe` or `pyspark.sql.Dataframe` and converts it into a pandas-on-spark dataframe. It also takes `pandas.Series` or `pyspark.sql.Dataframe` and converts it into a [pandas-on-spark](https://spark.apache.org/docs/latest/api/python/user_guide/pandas_on_spark/index.html) series. If you pass in a `pyspark.pandas.Dataframe`, it will not make any changes.\nThis function also accepts optional arguments `index_col` and `default_index_type`.\n- `index_col` is the column name to use as the index, default is None.\n- `default_index_type` is the default index type, default is \"distributed-sequence\". More info about default index type could be found on Spark official [documentation](https://spark.apache.org/docs/latest/api/python/user_guide/pandas_on_spark/options.html#default-index-type)\nHere is an example code snippet for Spark Data:\n```python\nimport pandas as pd\nfrom flaml.automl.spark.utils import to_pandas_on_spark\n# Creating a dictionary\ndata = {\n\"Square_Feet\": [800, 1200, 1800, 1500, 850],\n\"Age_Years\": [20, 15, 10, 7, 25],\n\"Price\": [100000, 200000, 300000, 240000, 120000],\n}\n# Creating a pandas DataFrame\ndataframe = pd.DataFrame(data)\nlabel = \"Price\"\n# Convert to pandas-on-spark dataframe\npsdf = to_pandas_on_spark(dataframe)\n```\nTo use Spark ML models you need to format your data appropriately. Specifically, use [`VectorAssembler`](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.ml.feature.VectorAssembler.html) to merge all feature columns into a single vector column.\nHere is an example of how to use it:\n```python\nfrom pyspark.ml.feature import VectorAssembler\ncolumns = psdf.columns\nfeature_cols = [col for col in columns if col != label]\nfeaturizer = VectorAssembler(inputCols=feature_cols, outputCol=\"features\")\npsdf = featurizer.transform(psdf.to_spark(index_col=\"index\"))[\"index\", \"features\"]\n```\nLater in conducting the experiment, use your pandas-on-spark data like non-spark data and pass them using `X_train, y_train` or `dataframe, label`.\n### Estimators\n#### Model List\n- `lgbm_spark`: The class for fine-tuning Spark version LightGBM models, using [SynapseML](https://microsoft.github.io/SynapseML/docs/features/lightgbm/about/) API.\n#### Usage\nFirst, prepare your data in the required format as described in the previous section.\nBy including the models you intend to try in the `estimators_list` argument to `flaml.automl`, FLAML will start trying configurations for these models. If your input is Spark data, FLAML will also use estimators with the `_spark` postfix by default, even if you haven't specified them.\nHere is an example code snippet using SparkML models in AutoML:\n```python\nimport flaml\n# prepare your data in pandas-on-spark format as we previously mentioned\nautoml = flaml.AutoML()\nsettings = {\n\"time_budget\": 30,\n\"metric\": \"r2\",\n\"estimator_list\": [\"lgbm_spark\"],  # this setting is optional\n\"task\": \"regression\",\n}\nautoml.fit(\ndataframe=psdf,\nlabel=label,\n**settings,\n)\n```\n[Link to notebook](https://github.com/microsoft/FLAML/blob/main/notebook/automl_bankrupt_synapseml.ipynb) | [Open in colab](https://colab.research.google.com/github/microsoft/FLAML/blob/main/notebook/automl_bankrupt_synapseml.ipynb)\n## Parallel Spark Jobs\nYou can activate Spark as the parallel backend during parallel tuning in both [AutoML](/docs/Use-Cases/Task-Oriented-AutoML#parallel-tuning) and [Hyperparameter Tuning](/docs/Use-Cases/Tune-User-Defined-Function#parallel-tuning), by setting the `use_spark` to `true`. FLAML will dispatch your job to the distributed Spark backend using [`joblib-spark`](https://github.com/joblib/joblib-spark).\nPlease note that you should not set `use_spark` to `true` when applying AutoML and Tuning for Spark Data. This is because only SparkML models will be used for Spark Data in AutoML and Tuning. As SparkML models run in parallel, there is no need to distribute them with `use_spark` again.\nAll the Spark-related arguments are stated below. These arguments are available in both Hyperparameter Tuning and AutoML:\n- `use_spark`: boolean, default=False | Whether to use spark to run the training in parallel spark jobs. This can be used to accelerate training on large models and large datasets, but will incur more overhead in time and thus slow down training in some cases. GPU training is not supported yet when use_spark is True. For Spark clusters, by default, we will launch one trial per executor. However, sometimes we want to launch more trials than the number of executors (e.g., local mode). In this case, we can set the environment variable `FLAML_MAX_CONCURRENT` to override the detected `num_executors`. The final number of concurrent trials will be the minimum of `n_concurrent_trials` and `num_executors`.\n- `n_concurrent_trials`: int, default=1 | The number of concurrent trials. When n_concurrent_trials > 1, FLAML performes parallel tuning.\n- `force_cancel`: boolean, default=False | Whether to forcely cancel Spark jobs if the search time exceeded the time budget. Spark jobs include parallel tuning jobs and Spark-based model training jobs.\nAn example code snippet for using parallel Spark jobs:\n```python\nimport flaml\nautoml_experiment = flaml.AutoML()\nautoml_settings = {\n\"time_budget\": 30,\n\"metric\": \"r2\",\n\"task\": \"regression\",\n\"n_concurrent_trials\": 2,\n\"use_spark\": True,\n\"force_cancel\": True,  # Activating the force_cancel option can immediately halt Spark jobs once they exceed the allocated time_budget.\n}\nautoml.fit(\ndataframe=dataframe,\nlabel=label,\n**automl_settings,\n)\n```\n[Link to notebook](https://github.com/microsoft/FLAML/blob/main/notebook/integrate_spark.ipynb) | [Open in colab](https://colab.research.google.com/github/microsoft/FLAML/blob/main/notebook/integrate_spark.ipynb)\n*************************************************************\n--------------------------------------------------------------------------------\nBoss\n(\nto\nchat_manager\n)\n:\n***** Response from calling function (retrieve_content) *****\nYou're a retrieve augmented coding assistant. You answer user's questions based on your own knowledge and the\ncontext provided by the user.\nIf you can't answer the question with or without the current context, you should reply exactly `UPDATE CONTEXT`.\nFor code generation, you must obey the following rules:\nRule 1. You MUST NOT install any packages because all the packages needed are already installed.\nRule 2. You must follow the formats below to write your code:\n```language\n# your code\n```\nUser's question is: using Apache Spark for parallel training in FLAML with sample code\nContext is: # Integrate - Spark\nFLAML has integrated Spark for distributed training. There are two main aspects of integration with Spark:\n- Use Spark ML estimators for AutoML.\n- Use Spark to run training in parallel spark jobs.\n## Spark ML Estimators\nFLAML integrates estimators based on Spark ML models. These models are trained in parallel using Spark, so we called them Spark estimators. To use these models, you first need to organize your data in the required format.\n### Data\nFor Spark estimators, AutoML only consumes Spark data. FLAML provides a convenient function `to_pandas_on_spark` in the `flaml.automl.spark.utils` module to convert your data into a pandas-on-spark (`pyspark.pandas`) dataframe/series, which Spark estimators require.\nThis utility function takes data in the form of a `pandas.Dataframe` or `pyspark.sql.Dataframe` and converts it into a pandas-on-spark dataframe. It also takes `pandas.Series` or `pyspark.sql.Dataframe` and converts it into a [pandas-on-spark](https://spark.apache.org/docs/latest/api/python/user_guide/pandas_on_spark/index.html) series. If you pass in a `pyspark.pandas.Dataframe`, it will not make any changes.\nThis function also accepts optional arguments `index_col` and `default_index_type`.\n- `index_col` is the column name to use as the index, default is None.\n- `default_index_type` is the default index type, default is \"distributed-sequence\". More info about default index type could be found on Spark official [documentation](https://spark.apache.org/docs/latest/api/python/user_guide/pandas_on_spark/options.html#default-index-type)\nHere is an example code snippet for Spark Data:\n```python\nimport pandas as pd\nfrom flaml.automl.spark.utils import to_pandas_on_spark\n# Creating a dictionary\ndata = {\n\"Square_Feet\": [800, 1200, 1800, 1500, 850],\n\"Age_Years\": [20, 15, 10, 7, 25],\n\"Price\": [100000, 200000, 300000, 240000, 120000],\n}\n# Creating a pandas DataFrame\ndataframe = pd.DataFrame(data)\nlabel = \"Price\"\n# Convert to pandas-on-spark dataframe\npsdf = to_pandas_on_spark(dataframe)\n```\nTo use Spark ML models you need to format your data appropriately. Specifically, use [`VectorAssembler`](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.ml.feature.VectorAssembler.html) to merge all feature columns into a single vector column.\nHere is an example of how to use it:\n```python\nfrom pyspark.ml.feature import VectorAssembler\ncolumns = psdf.columns\nfeature_cols = [col for col in columns if col != label]\nfeaturizer = VectorAssembler(inputCols=feature_cols, outputCol=\"features\")\npsdf = featurizer.transform(psdf.to_spark(index_col=\"index\"))[\"index\", \"features\"]\n```\nLater in conducting the experiment, use your pandas-on-spark data like non-spark data and pass them using `X_train, y_train` or `dataframe, label`.\n### Estimators\n#### Model List\n- `lgbm_spark`: The class for fine-tuning Spark version LightGBM models, using [SynapseML](https://microsoft.github.io/SynapseML/docs/features/lightgbm/about/) API.\n#### Usage\nFirst, prepare your data in the required format as described in the previous section.\nBy including the models you intend to try in the `estimators_list` argument to `flaml.automl`, FLAML will start trying configurations for these models. If your input is Spark data, FLAML will also use estimators with the `_spark` postfix by default, even if you haven't specified them.\nHere is an example code snippet using SparkML models in AutoML:\n```python\nimport flaml\n# prepare your data in pandas-on-spark format as we previously mentioned\nautoml = flaml.AutoML()\nsettings = {\n\"time_budget\": 30,\n\"metric\": \"r2\",\n\"estimator_list\": [\"lgbm_spark\"],  # this setting is optional\n\"task\": \"regression\",\n}\nautoml.fit(\ndataframe=psdf,\nlabel=label,\n**settings,\n)\n```\n[Link to notebook](https://github.com/microsoft/FLAML/blob/main/notebook/automl_bankrupt_synapseml.ipynb) | [Open in colab](https://colab.research.google.com/github/microsoft/FLAML/blob/main/notebook/automl_bankrupt_synapseml.ipynb)\n## Parallel Spark Jobs\nYou can activate Spark as the parallel backend during parallel tuning in both [AutoML](/docs/Use-Cases/Task-Oriented-AutoML#parallel-tuning) and [Hyperparameter Tuning](/docs/Use-Cases/Tune-User-Defined-Function#parallel-tuning), by setting the `use_spark` to `true`. FLAML will dispatch your job to the distributed Spark backend using [`joblib-spark`](https://github.com/joblib/joblib-spark).\nPlease note that you should not set `use_spark` to `true` when applying AutoML and Tuning for Spark Data. This is because only SparkML models will be used for Spark Data in AutoML and Tuning. As SparkML models run in parallel, there is no need to distribute them with `use_spark` again.\nAll the Spark-related arguments are stated below. These arguments are available in both Hyperparameter Tuning and AutoML:\n- `use_spark`: boolean, default=False | Whether to use spark to run the training in parallel spark jobs. This can be used to accelerate training on large models and large datasets, but will incur more overhead in time and thus slow down training in some cases. GPU training is not supported yet when use_spark is True. For Spark clusters, by default, we will launch one trial per executor. However, sometimes we want to launch more trials than the number of executors (e.g., local mode). In this case, we can set the environment variable `FLAML_MAX_CONCURRENT` to override the detected `num_executors`. The final number of concurrent trials will be the minimum of `n_concurrent_trials` and `num_executors`.\n- `n_concurrent_trials`: int, default=1 | The number of concurrent trials. When n_concurrent_trials > 1, FLAML performes parallel tuning.\n- `force_cancel`: boolean, default=False | Whether to forcely cancel Spark jobs if the search time exceeded the time budget. Spark jobs include parallel tuning jobs and Spark-based model training jobs.\nAn example code snippet for using parallel Spark jobs:\n```python\nimport flaml\nautoml_experiment = flaml.AutoML()\nautoml_settings = {\n\"time_budget\": 30,\n\"metric\": \"r2\",\n\"task\": \"regression\",\n\"n_concurrent_trials\": 2,\n\"use_spark\": True,\n\"force_cancel\": True,  # Activating the force_cancel option can immediately halt Spark jobs once they exceed the allocated time_budget.\n}\nautoml.fit(\ndataframe=dataframe,\nlabel=label,\n**automl_settings,\n)\n```\n[Link to notebook](https://github.com/microsoft/FLAML/blob/main/notebook/integrate_spark.ipynb) | [Open in colab](https://colab.research.google.com/github/microsoft/FLAML/blob/main/notebook/integrate_spark.ipynb)\n*************************************************************\n--------------------------------------------------------------------------------\nProduct_Manager\n(\nto\nchat_manager\n)\n:\nTo use Apache Spark for parallel training in FLAML, you can follow these steps:\n1. Ensure your data is in the required pandas-on-spark format.\n2. Use Spark ML estimators by including them in the `estimator_list`.\n3. Set `use_spark` to `True` for parallel tuning.\nHere's a sample code demonstrating how to use Spark for parallel training in FLAML:\n```python\nimport flaml\nfrom flaml.automl.spark.utils import to_pandas_on_spark\nimport pandas as pd\nfrom pyspark.ml.feature import VectorAssembler\n# Sample data in a pandas DataFrame\ndata = {\n\"Square_Feet\": [800, 1200, 1800, 1500, 850],\n\"Age_Years\": [20, 15, 10, 7, 25],\n\"Price\": [100000, 200000, 300000, 240000, 120000],\n}\nlabel = \"Price\"\n# Creating a pandas DataFrame\ndataframe = pd.DataFrame(data)\n# Convert to pandas-on-spark dataframe\npsdf = to_pandas_on_spark(dataframe)\n# Prepare features using VectorAssembler\ncolumns = psdf.columns\nfeature_cols = [col for col in columns if col != label]\nfeaturizer = VectorAssembler(inputCols=feature_cols, outputCol=\"features\")\npsdf = featurizer.transform(psdf.to_spark(index_col=\"index\"))[\"index\", \"features\"]\n# Initialize AutoML\nautoml = flaml.AutoML()\n# Configure settings for AutoML\nsettings = {\n\"time_budget\": 30,  # time budget in seconds\n\"metric\": \"r2\",\n\"estimator_list\": [\"lgbm_spark\"],  # using Spark ML estimators\n\"task\": \"regression\",\n\"n_concurrent_trials\": 2,  # number of parallel trials\n\"use_spark\": True,  # enable parallel training using Spark\n\"force_cancel\": True,  # force cancel Spark jobs if time_budget is exceeded\n}\n# Start the training\nautoml.fit(dataframe=psdf, label=label, **settings)\n```\nIn this code snippet:\n- The `to_pandas_on_spark` function is used to convert the pandas DataFrame to a pandas-on-spark DataFrame.\n- `VectorAssembler` is used to transform feature columns into a single vector column.\n- The `AutoML` object is created, and settings are configured for the AutoML run, including setting `use_spark` to `True` for parallel training.\n- The `fit` method is called to start the automated machine learning process.\nBy using these settings, FLAML will train the models in parallel using Spark, which can accelerate the training process on large models and datasets.\nTERMINATE\n--------------------------------------------------------------------------------"
                            }
                        },
                        {
                            "code": {
                                "language": "text",
                                "script": "Number of requested results 3 is greater than number of elements in index 1, updating n_results = 1\nModel gpt4-1106-preview not found. Using cl100k_base encoding."
                            }
                        }
                    ],
                    "subsections": []
                }
            ]
        }
    ],
    "images": []
}